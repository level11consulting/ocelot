{
  "swagger": "2.0",
  "info": {
    "title": "Guide Ocelot Server",
    "version": "1.0",
    "contact": {
      "name": "jessi shank",
      "email": "jessishank@level11.com"
    }
  },
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/build": {
      "post": {
        "summary": "trigger a build",
        "description": "build will attempt to trigger a build. If the git hash has already been built before, it can be triggered with just `acctRepo` and `hash` fields. If it has not been built before, the `branch` field is required as well.",
        "operationId": "BuildRepoAndHash",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "$ref": "#/x-stream-definitions/modelsLineResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsBuildReq"
            }
          }
        ],
        "tags": [
          "build-runtime",
          "overview"
        ]
      }
    },
    "/v1/buildruntime": {
      "get": {
        "summary": "get runtime specification of a specific build",
        "description": "buildRuntime is used for getting node details for an active build. When you query via a hash, ocelot will do a lookup in postgres for the top-level build information, then look in consul to find all of the runtime data, ie the werker node's ip and port for streaming build logs. \n If the build is finished and streaming logs should query the admin instead of the werker nodes, then the bool field `Done` will be true.",
        "operationId": "BuildRuntime",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsBuilds"
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash is the git hash that corresponds to a commit you wish to get information on.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "buildId",
            "description": "buildId is the build number given by ocelot that is associated with the commit.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "strip",
            "description": "strip will return builds without ansi // tty formatting.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "build-runtime"
        ]
      }
    },
    "/v1/creds/apple": {
      "get": {
        "summary": "Retrieve all apple related credentials",
        "operationId": "GetAppleCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsAppleCredsWrapper"
            }
          }
        },
        "tags": [
          "creds",
          "apple"
        ]
      },
      "post": {
        "summary": "Add new Apple Credential",
        "description": "Add New Apple credential. Currently only a apple developer profile is supported \nRefer to modelsAppleCreds for the object fields",
        "operationId": "SetAppleCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsAppleCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "apple"
        ]
      }
    },
    "/v1/creds/apple/{acctName}/{identifier}": {
      "get": {
        "summary": "return single apple cred",
        "description": "Returns apple cred if it exists. subType is a required query param",
        "operationId": "GetAppleCred",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsAppleCreds"
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate this credential with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier in dev profile creds is currently irrelevant, as there can only be one per account",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "appleSecrets",
            "description": "appleSecrets is the zip contents of the apple developer profile that you export in XCode ??.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "appleSecretsPassword",
            "description": "appleSecretsPassword is the password you set when you export the developer profile.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "@inject_tag: yaml:\"subType\".\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "apple"
        ]
      },
      "put": {
        "summary": "Update an apple config in ocelot for xcode integration. \nRefer to modelsAppleCreds for the object fields",
        "operationId": "UpdateAppleCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate this credential with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier in dev profile creds is currently irrelevant, as there can only be one per account",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsAppleCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "apple"
        ]
      }
    },
    "/v1/creds/env": {
      "get": {
        "summary": "Get all known generic credentials (env, helmrepo).",
        "description": "Get all known generic credentials (env, helmrepo).",
        "operationId": "GetGenericCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsGenericWrap"
            }
          }
        },
        "tags": [
          "creds",
          "env",
          "generic"
        ]
      },
      "post": {
        "summary": "Add new generic credentials (env, helmrepo)",
        "description": "Add new generic credentials. (env, helmrepo)",
        "operationId": "SetGenericCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsGenericCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "env",
          "generic"
        ]
      }
    },
    "/v1/creds/env/{acctName}/{identifier}": {
      "delete": {
        "summary": "Delete Generic / Env Credential, subType is a required query param",
        "operationId": "DeleteGenericCreds2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate integration cred with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for the integration",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "Subtypes are ENV, HELM_REPO.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "clientSecret",
            "description": "clientSecret is the secret associated with the integration cred.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "integration"
        ]
      },
      "put": {
        "summary": "Update a Generic Credential (env, helmrepo url)",
        "description": "Endpoint for updating a Generic credential in ocelot (ie ENV var or HELMREPO url). This should only be called if hte credential exists. subType is a required query param \nRefer to modelsGenericCreds for the object fields",
        "operationId": "UpdateGenericCreds2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate integration cred with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for the integration",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsGenericCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "vcs"
        ]
      }
    },
    "/v1/creds/generic": {
      "get": {
        "summary": "Get all known generic credentials (env, helmrepo).",
        "description": "Get all known generic credentials (env, helmrepo).",
        "operationId": "GetGenericCreds2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsGenericWrap"
            }
          }
        },
        "tags": [
          "creds",
          "env",
          "generic"
        ]
      },
      "post": {
        "summary": "Add new generic credentials (env, helmrepo)",
        "description": "Add new generic credentials. (env, helmrepo)",
        "operationId": "SetGenericCreds2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsGenericCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "env",
          "generic"
        ]
      }
    },
    "/v1/creds/generic/{acctName}/{identifier}": {
      "delete": {
        "summary": "Delete Generic / Env Credential, subType is a required query param",
        "operationId": "DeleteGenericCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate integration cred with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for the integration",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "Subtypes are ENV, HELM_REPO.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "clientSecret",
            "description": "clientSecret is the secret associated with the integration cred.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "integration"
        ]
      },
      "put": {
        "summary": "Update a Generic Credential (env, helmrepo url)",
        "description": "Endpoint for updating a Generic credential in ocelot (ie ENV var or HELMREPO url). This should only be called if hte credential exists. subType is a required query param \nRefer to modelsGenericCreds for the object fields",
        "operationId": "UpdateGenericCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate integration cred with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for the integration",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsGenericCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "vcs"
        ]
      }
    },
    "/v1/creds/k8s": {
      "get": {
        "summary": "Retrieve all kubernetes related credentials",
        "operationId": "GetK8SCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsK8SCredsWrapper"
            }
          }
        },
        "tags": [
          "creds",
          "kubernetes"
        ]
      },
      "post": {
        "summary": "Add new Kubernetes Credential",
        "description": "Add New kubernetes credential. \nRefer to modelsK8SCreds for the object fields",
        "operationId": "SetK8SCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsK8SCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "kubernetes"
        ]
      }
    },
    "/v1/creds/k8s/{acctName}/{identifier}": {
      "get": {
        "summary": "get Kubernetes credential",
        "description": "Returns k8s cred if it exists. subtype is a required query param",
        "operationId": "GetK8SCred",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsK8SCreds"
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate this credential with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier in K8s creds, typically the name of the cluster, as expected use case is one config per cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "k8sContents",
            "description": "k8scontents is the contents of the kubeconfig file.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "@inject_tag: yaml:\"subType\"\nthere is currently only one subtype for k8SCreds, and it is KUBECONF.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "kubernetes"
        ]
      },
      "delete": {
        "summary": "Delete Kubernetes Credential, subType is a required query param",
        "operationId": "DeleteK8SCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate this credential with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier in K8s creds, typically the name of the cluster, as expected use case is one config per cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "k8sContents",
            "description": "k8scontents is the contents of the kubeconfig file.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "@inject_tag: yaml:\"subType\"\nthere is currently only one subtype for k8SCreds, and it is KUBECONF.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "kubernetes"
        ]
      },
      "put": {
        "summary": "Update a kubeconfig in ocelot for kubernetes integration. \nRefer to modelsK8SCreds for the object fields",
        "operationId": "UpdateK8SCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate this credential with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier in K8s creds, typically the name of the cluster, as expected use case is one config per cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsK8SCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "kubernetes"
        ]
      }
    },
    "/v1/creds/notify": {
      "get": {
        "summary": "Get all known Notify integration credentials.",
        "operationId": "GetNotifyCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsNotifyWrap"
            }
          }
        },
        "tags": [
          "creds",
          "notify"
        ]
      },
      "post": {
        "summary": "Attach new notification integration to account",
        "description": "Attach a new notify integration to an account ",
        "operationId": "SetNotifyCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsNotifyCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "notify"
        ]
      }
    },
    "/v1/creds/notify/{acctName}/{identifier}": {
      "get": {
        "summary": "get notify integration credential",
        "description": "Returns notify integration cred if it exists. subtype is a required query param",
        "operationId": "GetNotifyCred",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsNotifyCreds"
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate integration cred with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for the integration",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "There is currently only one subType that is valid for Integrations, and it is SLACK.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "clientSecret",
            "description": "clientSecret is the secret associated with the integration cred.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "detailUrlBase",
            "description": "detailUrlBase is the base url for an ocelot ui. when building the notification, will\n  add {{detailUrlBase}}/repos/{{account}}/{{repo}}/{{buildId}}.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "notify"
        ]
      },
      "delete": {
        "summary": "Delete Notify Credential. subType is a required query param",
        "operationId": "DeleteNotifyCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate integration cred with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for the integration",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "There is currently only one subType that is valid for Integrations, and it is SLACK.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "clientSecret",
            "description": "clientSecret is the secret associated with the integration cred.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "detailUrlBase",
            "description": "detailUrlBase is the base url for an ocelot ui. when building the notification, will\n  add {{detailUrlBase}}/repos/{{account}}/{{repo}}/{{buildId}}.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "integration"
        ]
      },
      "put": {
        "summary": "Update a notify integration cred",
        "operationId": "UpdateNotifyCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate integration cred with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for the integration",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsNotifyCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "integration"
        ]
      }
    },
    "/v1/creds/repo": {
      "get": {
        "summary": "Get all known repo integration credentials.",
        "description": "Get all known repo integration credentials.",
        "operationId": "GetRepoCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsRepoCredWrapper"
            }
          }
        },
        "tags": [
          "creds",
          "repo"
        ]
      },
      "post": {
        "summary": "Add new Repo cred",
        "description": "Add new repo credential. password, repoUrl, acctName, username and type are required. type must be nexus|docker. \nRefer to modelsRepoCreds for the object fields",
        "operationId": "SetRepoCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsRepoCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "repo"
        ]
      }
    },
    "/v1/creds/repo/{acctName}/{identifier}": {
      "get": {
        "summary": "return single repo cred",
        "description": "Returns repo cred if it exists. subType is a required query param",
        "operationId": "GetRepoCred",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsRepoCreds"
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "@inject_tag: yaml:\"acctName\"\naccount name (same as from vcs)",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier that is associated with this acctName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "username",
            "description": "username of repository.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "password",
            "description": "password of repository.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "repoUrl",
            "description": "@inject_tag: yaml:\"repoUrl\"\nrepoUrl is the url that is associated with that repository, for example hub.docker.io.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "@inject_tag: yaml:\"subType\"\nthere are two subtypes that are valid for RepoCreds: DOCKER, NEXUS.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "repo"
        ]
      },
      "delete": {
        "summary": "Delete Repo Credential, subType is a required query param",
        "operationId": "DeleteRepoCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "@inject_tag: yaml:\"acctName\"\naccount name (same as from vcs)",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier that is associated with this acctName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "username",
            "description": "username of repository.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "password",
            "description": "password of repository.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "repoUrl",
            "description": "@inject_tag: yaml:\"repoUrl\"\nrepoUrl is the url that is associated with that repository, for example hub.docker.io.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "@inject_tag: yaml:\"subType\"\nthere are two subtypes that are valid for RepoCreds: DOCKER, NEXUS.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "repo"
        ]
      },
      "put": {
        "summary": "Update repo credential",
        "description": "update new credential configuration to ocelot for repository integration. \nRefer to modelsRepoCreds for the object fields",
        "operationId": "UpdateRepoCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "@inject_tag: yaml:\"acctName\"\naccount name (same as from vcs)",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier that is associated with this acctName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsRepoCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "repo"
        ]
      }
    },
    "/v1/creds/ssh": {
      "get": {
        "summary": "Get all known SSH integration credentials.",
        "operationId": "GetSSHCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsSSHWrap"
            }
          }
        },
        "tags": [
          "creds",
          "ssh"
        ]
      },
      "post": {
        "summary": "Attach new SSH key to account",
        "description": "Add a new ssh key to an account so builds can access them at runtime. \nRefer to modelsSSHKeyWrapper for the object fields",
        "operationId": "SetSSHCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsSSHKeyWrapper"
            }
          }
        ],
        "tags": [
          "creds",
          "ssh"
        ]
      }
    },
    "/v1/creds/ssh/{acctName}/{identifier}": {
      "get": {
        "summary": "retrieve single ssh key",
        "description": "Returns ssh cred if it exists. subtype is a required query param",
        "operationId": "GetSSHCred",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsSSHKeyWrapper"
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate ssh key with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for when an ssh key is not associated with a VCS account.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "privateKey",
            "description": "the contents of the private key.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "subType",
            "description": "There is only one subType taht is valid for SSHKeyWrapper, and it is SSHKEY.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "ssh"
        ]
      },
      "delete": {
        "summary": "Delete an SSH Credential, subType is a required query param",
        "operationId": "DeleteSSHCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate ssh key with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for when an ssh key is not associated with a VCS account.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "privateKey",
            "description": "the contents of the private key.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "subType",
            "description": "There is only one subType taht is valid for SSHKeyWrapper, and it is SSHKEY.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "ssh"
        ]
      },
      "put": {
        "summary": "Update ssh key",
        "description": "Update a ssh key for use in build scripts. Must already exist in the database. \nRefer to modelsSSHKeyWrapper for the object fields",
        "operationId": "UpdateSSHCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate ssh key with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for when an ssh key is not associated with a VCS account.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsSSHKeyWrapper"
            }
          }
        ],
        "tags": [
          "creds",
          "ssh"
        ]
      }
    },
    "/v1/creds/vcs": {
      "get": {
        "summary": "Return all vcs creds",
        "description": "Returns all VCS creds that ocelot has and can use for checking out code to build.",
        "operationId": "GetVCSCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsCredWrapper"
            }
          }
        },
        "tags": [
          "creds",
          "vcs"
        ]
      },
      "post": {
        "summary": "Add VCS Credential",
        "description": "Add a new VCS credential configuration to ocelot for code checkout. \nRefer to modelsVCSCreds for the object fields",
        "operationId": "SetVCSCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsVCSCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "vcs"
        ]
      }
    },
    "/v1/creds/vcs/{acctName}/{identifier}": {
      "get": {
        "summary": "Retrieve single VCS cred",
        "description": "Returns vcs cred if it exists. subtype is a required query param. \nRefer to modelsVCSCreds for the object fields",
        "operationId": "GetVCSCred",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsVCSCreds"
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "@inject_tag: yaml:\"acctName\"\nacctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the name the user calls teh credential set",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "clientId",
            "description": "clientId is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.\n@inject_tag: yaml:\"clientId\".",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientSecret",
            "description": "clientSecret is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.\n@inject_tag: yaml:\"clientSecret\".",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "tokenURL",
            "description": "tokenUrl is the url at which to retrieve the token\n@inject_tag: yaml:\"tokenURL\".",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "sshFileLoc",
            "description": "just a string that says whether or not there is an ssh key on file\n@inject_tag: yaml:\"sshFileLoc\".",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "subType",
            "description": "there is only one subtype that is valid for VCS creds at this time, and it is BITBUCKET\n@inject_tag: yaml:\"subType\".\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "id",
            "description": "id is credentials id from database.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "creds",
          "vcs"
        ]
      },
      "put": {
        "summary": "Update a VCS Credential",
        "description": "Endpoint for updating a VCS credential in ocelot. This should only be called if hte credential exists. subType is a required query param \nRefer to modelsVCSCreds for the object fields",
        "operationId": "UpdateVCSCreds",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "@inject_tag: yaml:\"acctName\"\nacctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the name the user calls teh credential set",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsVCSCreds"
            }
          }
        ],
        "tags": [
          "creds",
          "vcs"
        ]
      }
    },
    "/v1/creds/vcs/{acctName}/{identifier}/ssh": {
      "post": {
        "summary": "Attach ssh key to VCS Account",
        "description": "Attach the contents of an ssh file to a vcs account. This file will be attached to the build container for cloning the repository. subType is a required query param \nRefer to modelsSSHKeyWrapper for the object fields",
        "operationId": "SetVCSPrivateKey",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "acctName",
            "description": "account name to associate ssh key with",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identifier",
            "description": "identifier is the unique identifier for when an ssh key is not associated with a VCS account.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsSSHKeyWrapper"
            }
          }
        ],
        "tags": [
          "creds",
          "vcs"
        ]
      }
    },
    "/v1/logs": {
      "get": {
        "summary": "stream logs of a previous build",
        "description": "get stream of logs for a specific build. can either query by buildId or hash, if buildId is specified it takes precendence over hash. \n This method will error out if the build is still active. Active builds MUST be streamed from the werkers themselves, and  you must call /v1/buildruntime to retrive the werker connection information  \nif hash is specified and there are multiple builds with the same hash, ocelot will stream the latest one. \nRefer to modelsBuildQuery for object fields",
        "operationId": "Logs",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "$ref": "#/x-stream-definitions/modelsLineResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash is the git hash that corresponds to a commit you wish to get information on.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "buildId",
            "description": "buildId is the build number given by ocelot that is associated with the commit.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "strip",
            "description": "strip will return builds without ansi // tty formatting.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          }
        ],
        "tags": [
          "build-runtime"
        ]
      }
    },
    "/v1/poll": {
      "get": {
        "summary": "list all repositories that are being polled for changes",
        "description": "list all repositories that are being polled for changes",
        "operationId": "ListPolledRepos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsPolls"
            }
          }
        },
        "tags": [
          "tracking"
        ]
      },
      "post": {
        "summary": "set up git poll tracking for a repository",
        "description": "poll will set up a polling request. `account`, `repo`, `cron`, and `branches` are all required fields.",
        "operationId": "PollRepo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsPollRequest"
            }
          }
        ],
        "tags": [
          "tracking"
        ]
      }
    },
    "/v1/poll/{account}/{repo}": {
      "delete": {
        "summary": "delete poll tracking for a repo",
        "description": "delete polling for a repo",
        "operationId": "DeletePollRepo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "account",
            "description": "account is the VCS account",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "repo",
            "description": "repo is the VCS repository name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "cron",
            "description": "cron is the cron string that will determine how often a check for changes should occur.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "branches",
            "description": "branches tells ocelot which branches should be checked for changes.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "type",
            "description": "type is the vcs subcredtype, ie github|bitbucket.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          },
          {
            "name": "lastCronTime",
            "description": "internal use only.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          }
        ],
        "tags": [
          "tracking"
        ]
      }
    },
    "/v1/status": {
      "get": {
        "summary": "get detailed status on every stage in a build",
        "description": "GetStatus will return the status of a specific build. Hierarchy for key to lookup with: if `hash` supplied, ocelot will only get status by hash. If `acctName` and `repoName` are supplied and not hash, it will be used as a key for looking up status. If only `partialRepo` is given in the request, ocelot will attempt to find a match and return the latest build stage details for that.",
        "operationId": "GetStatus",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash is the git hash to get status of.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "acctName",
            "description": "acctName is the corresponding account that the hash is attached to.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "repoName",
            "description": "repoName is the corresponding repo name that the hash is attached to.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "partialRepo",
            "description": "partialRepo is just the first n letters of repo.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "buildId",
            "description": "buildId is the database build id corresponding to the build you need status of.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "overview",
          "build-runtime"
        ]
      }
    },
    "/v1/summary/{account}/{repo}": {
      "get": {
        "summary": "retrive summaries corresponding to an account \u0026 repo",
        "description": "will return summaries of the builds for the corresponding repo/account. limit will set how many entries will be returned",
        "operationId": "LastFewSummaries",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsSummaries"
            }
          }
        },
        "parameters": [
          {
            "name": "account",
            "description": "account is the VCS account",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "repo",
            "description": "repo is the VCS repository",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "limit",
            "description": "limit is the number of summary records desired to be returned.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "type",
            "description": "type is the vcs type fo the account and repo.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          }
        ],
        "tags": [
          "overview"
        ]
      }
    },
    "/v1/tracked-repositories": {
      "get": {
        "summary": "get list of all currently tracked account/repos",
        "operationId": "GetTrackedRepos",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsAcctRepos"
            }
          }
        },
        "tags": [
          "tracking"
        ]
      }
    },
    "/v1/watch": {
      "post": {
        "summary": "create a webhook in bitbucket for a repository",
        "description": "watch will set up a webhook for the given repo/account. `repo`, `account`, and `limit` are required fields in the POST body",
        "operationId": "WatchRepo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "properties": {}
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/modelsRepoAccount"
            }
          }
        ],
        "tags": [
          "tracking"
        ]
      }
    },
    "/v1/werker/{hash}": {
      "get": {
        "summary": "get details of node running specific build",
        "description": "get network location of werker that is currrently executing a build on the specifed hash. use when you want to kill a specific build to get werker node info. ",
        "operationId": "FindWerker",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/modelsBuildRuntimeInfo"
            }
          }
        },
        "parameters": [
          {
            "name": "hash",
            "description": "hash is the git hash to trigger.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "acctRepo",
            "description": "acctRepo is the ocelot account to which the creds are uploaded and the repository you wish to operate on, in the form account/repo.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "branch",
            "description": "branch is the branch that corresponds to the git hash. if the git hash has never been built by ocelot, this field is required.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "force",
            "description": "force is a flag that says to build even if it doesn't match the acceptable branches list and even if there is a \"skip\" ci message.",
            "in": "query",
            "required": false,
            "type": "boolean",
            "format": "boolean"
          },
          {
            "name": "vcsType",
            "description": "vcsType is the vcs sub cred type that is associated with the acct/repo you wish to build.\n GITHUB|BITBUCKET. If this is not passed in a build request then the credentials table will be checked\n to see if there is only one account with that name to infer subcredtype from. If there is more than one\n account with different subcredtypes, then an error will be returned to and it will be required to pass this\n field.\n\n - BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NIL_SCT",
              "BITBUCKET",
              "GITHUB",
              "NEXUS",
              "MAVEN",
              "DOCKER",
              "MINIO",
              "KUBECONF",
              "SSHKEY",
              "SLACK",
              "DEVPROFILE",
              "ENV",
              "HELM_REPO"
            ],
            "default": "NIL_SCT"
          }
        ],
        "tags": [
          "build-runtime"
        ]
      }
    }
  },
  "definitions": {
    "modelsAcctRepo": {
      "type": "object",
      "properties": {
        "account": {
          "type": "string",
          "title": "account is VCS Account"
        },
        "repo": {
          "type": "string",
          "title": "repo is the VCS Repository"
        },
        "lastQueue": {
          "type": "string",
          "format": "date-time",
          "title": "lastqueue last time build was queued"
        }
      },
      "title": "Used in displaying all repos that are tracked by ocelot"
    },
    "modelsAcctRepos": {
      "type": "object",
      "properties": {
        "acctRepos": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsAcctRepo"
          }
        }
      },
      "title": "AcctRepos is used in the response to /v1/tracked-repositories, it is an array of AcctRepo objects. have to wrap it cuz proto -_-"
    },
    "modelsAllCredsWrapper": {
      "type": "object",
      "properties": {
        "repoCreds": {
          "$ref": "#/definitions/modelsRepoCredWrapper",
          "title": "All repository credentials for integrations\n@inject_tag: yaml:\"repoCreds\""
        },
        "vcsCreds": {
          "$ref": "#/definitions/modelsCredWrapper",
          "title": "All VCS credentials for building\n@inject_tag: yaml:\"vcsCreds\""
        }
      }
    },
    "modelsAppleCreds": {
      "type": "object",
      "properties": {
        "acctName": {
          "type": "string",
          "title": "account name to associate this credential with"
        },
        "identifier": {
          "type": "string",
          "title": "identifier in dev profile creds is currently irrelevant, as there can only be one per account"
        },
        "appleSecrets": {
          "type": "string",
          "format": "byte",
          "title": "appleSecrets is the zip contents of the apple developer profile that you export in XCode ??"
        },
        "appleSecretsPassword": {
          "type": "string",
          "title": "appleSecretsPassword is the password you set when you export the developer profile"
        },
        "subType": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "@inject_tag: yaml:\"subType\""
        },
        "id": {
          "type": "string",
          "format": "int64",
          "title": "id is credentials id from database"
        }
      }
    },
    "modelsAppleCredsWrapper": {
      "type": "object",
      "properties": {
        "appleCreds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsAppleCreds"
          }
        }
      }
    },
    "modelsBuildReq": {
      "type": "object",
      "properties": {
        "acctRepo": {
          "type": "string",
          "title": "acctRepo is the ocelot account to which the creds are uploaded and the repository you wish to operate on, in the form account/repo"
        },
        "hash": {
          "type": "string",
          "description": "hash is the git hash to trigger."
        },
        "branch": {
          "type": "string",
          "description": "branch is the branch that corresponds to the git hash. if the git hash has never been built by ocelot, this field is required."
        },
        "force": {
          "type": "boolean",
          "format": "boolean",
          "title": "force is a flag that says to build even if it doesn't match the acceptable branches list and even if there is a \"skip\" ci message"
        },
        "vcsType": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "vcsType is the vcs sub cred type that is associated with the acct/repo you wish to build.\n GITHUB|BITBUCKET. If this is not passed in a build request then the credentials table will be checked\n to see if there is only one account with that name to infer subcredtype from. If there is more than one\n account with different subcredtypes, then an error will be returned to and it will be required to pass this\n field"
        }
      }
    },
    "modelsBuildRuntimeInfo": {
      "type": "object",
      "properties": {
        "done": {
          "type": "boolean",
          "format": "boolean",
          "title": "done says whether or not the build has completed"
        },
        "ip": {
          "type": "string",
          "title": "ip is the ip of the werker node that is running the build"
        },
        "grpcPort": {
          "type": "string",
          "title": "grpcPort is the grpc port of the werker running the build"
        },
        "hash": {
          "type": "string",
          "title": "hash is the git hash that is currently being built"
        },
        "acctName": {
          "type": "string",
          "title": "acctName is the vcs account that this build is assocated with"
        },
        "repoName": {
          "type": "string",
          "title": "repoName is the name of the git repository that is associated with this commit/build"
        },
        "wsPort": {
          "type": "string"
        }
      }
    },
    "modelsBuildStatus": {
      "type": "string",
      "enum": [
        "NIL",
        "QUEUED",
        "RUNNING",
        "FAILED",
        "PASSED",
        "FAILED_PRESTART"
      ],
      "default": "NIL"
    },
    "modelsBuildSummary": {
      "type": "object",
      "properties": {
        "hash": {
          "type": "string",
          "title": "hash is the git commit hash that corresponds with this build information"
        },
        "failed": {
          "type": "boolean",
          "format": "boolean",
          "title": "failed is whether or not the build failed"
        },
        "buildTime": {
          "type": "string",
          "format": "date-time",
          "title": "buildTime is the datetime that the build was picked up off the queue by the werker"
        },
        "account": {
          "type": "string",
          "title": "account is the VCS account associated with the repository / commit"
        },
        "buildDuration": {
          "type": "number",
          "format": "double",
          "title": "buildDuration is the length of time the whole build took to execute"
        },
        "repo": {
          "type": "string",
          "title": "repo is the repository associated with the account / commit"
        },
        "branch": {
          "type": "string",
          "title": "branch is the branch associated with the commit when it was pushed"
        },
        "buildId": {
          "type": "string",
          "format": "int64",
          "title": "buildId is the id given to the build entry by postgres. it is unique"
        },
        "queueTime": {
          "type": "string",
          "format": "date-time",
          "title": "queueTime is the datetime that either a tracking component or the admin put the build request on the queue to be processed by the werker node"
        },
        "status": {
          "$ref": "#/definitions/modelsBuildStatus",
          "title": "status is the current status of the build as known by the database"
        },
        "signaledBy": {
          "$ref": "#/definitions/modelsSignaledBy",
          "title": "signaledBy is what resulted in the build being queued: pull_request,push,poll,requested,subscribed"
        },
        "credentialsId": {
          "type": "string",
          "format": "int64",
          "title": "credentialsId is the id of the credential in the cred table in db"
        }
      },
      "description": "BuildSummary represents the build_summary table in postgres\nit is a top level view of how a repository is \"doing\" in ocelot, ie build times, fail status.."
    },
    "modelsBuilds": {
      "type": "object",
      "properties": {
        "builds": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/modelsBuildRuntimeInfo"
          }
        }
      }
    },
    "modelsCredWrapper": {
      "type": "object",
      "properties": {
        "vcs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsVCSCreds"
          }
        }
      },
      "title": "just a container for a list of VCSCreds"
    },
    "modelsExists": {
      "type": "object",
      "properties": {
        "exists": {
          "type": "boolean",
          "format": "boolean"
        }
      }
    },
    "modelsGenericCreds": {
      "type": "object",
      "properties": {
        "acctName": {
          "type": "string",
          "title": "account name to associate integration cred with"
        },
        "subType": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "Subtypes are ENV, HELM_REPO"
        },
        "identifier": {
          "type": "string",
          "title": "identifier is the unique identifier for the integration"
        },
        "clientSecret": {
          "type": "string",
          "title": "clientSecret is the secret associated with the integration cred"
        },
        "id": {
          "type": "string",
          "format": "int64",
          "title": "id is credentials id from database"
        }
      }
    },
    "modelsGenericWrap": {
      "type": "object",
      "properties": {
        "creds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsGenericCreds"
          }
        }
      }
    },
    "modelsK8SCreds": {
      "type": "object",
      "properties": {
        "acctName": {
          "type": "string",
          "title": "account name to associate this credential with"
        },
        "k8sContents": {
          "type": "string",
          "title": "k8scontents is the contents of the kubeconfig file"
        },
        "identifier": {
          "type": "string",
          "title": "identifier in K8s creds, typically the name of the cluster, as expected use case is one config per cluster"
        },
        "subType": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "@inject_tag: yaml:\"subType\"\nthere is currently only one subtype for k8SCreds, and it is KUBECONF"
        },
        "id": {
          "type": "string",
          "format": "int64",
          "title": "id is credentials id from database"
        }
      }
    },
    "modelsK8SCredsWrapper": {
      "type": "object",
      "properties": {
        "K8SCreds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsK8SCreds"
          }
        }
      }
    },
    "modelsLineResponse": {
      "type": "object",
      "properties": {
        "outputLine": {
          "type": "string"
        }
      }
    },
    "modelsNotifyCreds": {
      "type": "object",
      "properties": {
        "acctName": {
          "type": "string",
          "title": "account name to associate integration cred with"
        },
        "subType": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "There is currently only one subType that is valid for Integrations, and it is SLACK"
        },
        "identifier": {
          "type": "string",
          "title": "identifier is the unique identifier for the integration"
        },
        "clientSecret": {
          "type": "string",
          "title": "clientSecret is the secret associated with the integration cred"
        },
        "detailUrlBase": {
          "type": "string",
          "title": "detailUrlBase is the base url for an ocelot ui. when building the notification, will\n  add {{detailUrlBase}}/repos/{{account}}/{{repo}}/{{buildId}}"
        },
        "id": {
          "type": "string",
          "format": "int64",
          "title": "id is credentials id from database"
        }
      }
    },
    "modelsNotifyWrap": {
      "type": "object",
      "properties": {
        "creds": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsNotifyCreds"
          }
        }
      }
    },
    "modelsPollRequest": {
      "type": "object",
      "properties": {
        "account": {
          "type": "string",
          "title": "account is the VCS account"
        },
        "repo": {
          "type": "string",
          "title": "repo is the VCS repository name"
        },
        "cron": {
          "type": "string",
          "title": "cron is the cron string that will determine how often a check for changes should occur"
        },
        "branches": {
          "type": "string",
          "title": "branches tells ocelot which branches should be checked for changes"
        },
        "type": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "type is the vcs subcredtype, ie github|bitbucket"
        },
        "lastCronTime": {
          "type": "string",
          "format": "date-time",
          "title": "internal use only"
        },
        "lastHashes": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "internal use only"
        }
      },
      "description": "PollRequest encompasses all the data necessary to set up poll tracking in ocelot."
    },
    "modelsPolls": {
      "type": "object",
      "properties": {
        "polls": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsPollRequest"
          }
        }
      },
      "title": "polls is a wrapper for a PollRequest list because protobuf can be dumb"
    },
    "modelsRepoAccount": {
      "type": "object",
      "properties": {
        "repo": {
          "type": "string",
          "title": "repo is the VCS repository"
        },
        "account": {
          "type": "string",
          "title": "account is the VCS account"
        },
        "limit": {
          "type": "integer",
          "format": "int32",
          "title": "limit is the number of summary records desired to be returned"
        },
        "type": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "type is the vcs type fo the account and repo"
        }
      }
    },
    "modelsRepoCredWrapper": {
      "type": "object",
      "properties": {
        "repo": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsRepoCreds"
          }
        }
      },
      "title": "container for list of repo creds"
    },
    "modelsRepoCreds": {
      "type": "object",
      "properties": {
        "username": {
          "type": "string",
          "title": "username of repository"
        },
        "password": {
          "type": "string",
          "title": "password of repository"
        },
        "repoUrl": {
          "type": "string",
          "title": "@inject_tag: yaml:\"repoUrl\"\nrepoUrl is the url that is associated with that repository, for example hub.docker.io"
        },
        "identifier": {
          "type": "string",
          "title": "identifier is the unique identifier that is associated with this acctName"
        },
        "acctName": {
          "type": "string",
          "title": "@inject_tag: yaml:\"acctName\"\naccount name (same as from vcs)"
        },
        "subType": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "@inject_tag: yaml:\"subType\"\nthere are two subtypes that are valid for RepoCreds: DOCKER, NEXUS"
        },
        "id": {
          "type": "string",
          "format": "int64",
          "title": "id is credentials id from database"
        }
      }
    },
    "modelsSSHKeyWrapper": {
      "type": "object",
      "properties": {
        "acctName": {
          "type": "string",
          "title": "account name to associate ssh key with"
        },
        "privateKey": {
          "type": "string",
          "format": "byte",
          "title": "the contents of the private key"
        },
        "subType": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "There is only one subType taht is valid for SSHKeyWrapper, and it is SSHKEY"
        },
        "identifier": {
          "type": "string",
          "description": "identifier is the unique identifier for when an ssh key is not associated with a VCS account."
        },
        "id": {
          "type": "string",
          "format": "int64",
          "title": "id is credentials id from database"
        }
      }
    },
    "modelsSSHWrap": {
      "type": "object",
      "properties": {
        "keys": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsSSHKeyWrapper"
          }
        }
      }
    },
    "modelsSignaledBy": {
      "type": "string",
      "enum": [
        "PULL_REQUEST",
        "PUSH",
        "POLL",
        "REQUESTED",
        "SUBSCRIBED"
      ],
      "default": "PULL_REQUEST"
    },
    "modelsStageStatus": {
      "type": "object",
      "properties": {
        "StageStatus": {
          "type": "string"
        },
        "error": {
          "type": "string",
          "title": "error is the error message; will either be populated by a stage not returning exit code 0 or an error handled in the code during the build"
        },
        "status": {
          "type": "integer",
          "format": "int32",
          "title": "status is whether or not hte build failed; 0 for pass; 1 for failed"
        },
        "messages": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "messages are some descriptions of each stage that are generated at runtime"
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "startTime is when this stage began execution"
        },
        "stageDuration": {
          "type": "number",
          "format": "double",
          "title": "stageDuration is how long the stage took to execute"
        }
      },
      "title": "StageStatus is the detailed information about a specific stage that was executed during the build"
    },
    "modelsStatus": {
      "type": "object",
      "properties": {
        "buildSum": {
          "$ref": "#/definitions/modelsBuildSummary",
          "title": "buildSum is the BuildSummary object that correlates to the build in question"
        },
        "stages": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsStageStatus"
          },
          "title": "stages is a all the StageStatus objects associated to the build in question"
        },
        "isInConsul": {
          "type": "boolean",
          "format": "boolean",
          "title": "isInConsul is a boolean that is used for determining if the build is \"running\" or not. if isInConsul=true, the build is still running"
        }
      }
    },
    "modelsSubCredType": {
      "type": "string",
      "enum": [
        "NIL_SCT",
        "BITBUCKET",
        "GITHUB",
        "NEXUS",
        "MAVEN",
        "DOCKER",
        "MINIO",
        "KUBECONF",
        "SSHKEY",
        "SLACK",
        "DEVPROFILE",
        "ENV",
        "HELM_REPO"
      ],
      "default": "NIL_SCT",
      "title": "- BITBUCKET: / VCS ///\n - NEXUS: / REPO ///\n - KUBECONF: / K8S ///\n - SSHKEY: / SSH ///\n - SLACK: / NOTIFY ///\n - DEVPROFILE: / APPLE ///\n - ENV: / GENERIC ///"
    },
    "modelsSummaries": {
      "type": "object",
      "properties": {
        "sums": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/modelsBuildSummary"
          }
        }
      },
      "title": "summaries is a wrapper for a list of BuildSummary objects because protobuf can be dumb"
    },
    "modelsVCSCreds": {
      "type": "object",
      "properties": {
        "clientId": {
          "type": "string",
          "title": "clientId is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.\n@inject_tag: yaml:\"clientId\""
        },
        "clientSecret": {
          "type": "string",
          "title": "clientSecret is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.\n@inject_tag: yaml:\"clientSecret\""
        },
        "identifier": {
          "type": "string",
          "title": "identifier is the name the user calls teh credential set"
        },
        "tokenURL": {
          "type": "string",
          "title": "tokenUrl is the url at which to retrieve the token\n@inject_tag: yaml:\"tokenURL\""
        },
        "acctName": {
          "type": "string",
          "title": "@inject_tag: yaml:\"acctName\"\nacctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)"
        },
        "sshFileLoc": {
          "type": "string",
          "title": "just a string that says whether or not there is an ssh key on file\n@inject_tag: yaml:\"sshFileLoc\""
        },
        "subType": {
          "$ref": "#/definitions/modelsSubCredType",
          "title": "there is only one subtype that is valid for VCS creds at this time, and it is BITBUCKET\n@inject_tag: yaml:\"subType\""
        },
        "id": {
          "type": "string",
          "format": "int64",
          "title": "id is credentials id from database"
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "type_url": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        },
        "value": {
          "type": "string",
          "format": "byte",
          "description": "Must be a valid serialized protocol buffer of the above specified type."
        }
      },
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := \u0026pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "runtimeStreamError": {
      "type": "object",
      "properties": {
        "grpc_code": {
          "type": "integer",
          "format": "int32"
        },
        "http_code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "http_status": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    }
  },
  "x-stream-definitions": {
    "modelsLineResponse": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/modelsLineResponse"
        },
        "error": {
          "$ref": "#/definitions/runtimeStreamError"
        }
      },
      "title": "Stream result of modelsLineResponse"
    }
  }
}
